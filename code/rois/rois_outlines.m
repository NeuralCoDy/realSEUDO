% Generate the ROIs outlines superimposed on the heatmap of the movie.
% The outlines are drawn with color 255, while the heatmap gets rescaled
% to the range [0, 254].
%
% Args:
% heatmap - the heatmap image X*Y 
% rois - ROIs containing the images X*Y
% tags - numeric tags for the ROIs to display, if empty then no tags will be shown,
%   must have the same size as the number of the ROIs or be empty;
%   at most 2 digits per tag are supported
% Parameters:
% upscale - scaling factor to make the outlines thinner, use the
%   powers of 2, the typical good values are 4 (default) or 8
% thickness - the "opposite" of upscale, draws the boundaries thicker,
%   defaults to 1, can be used together with upscale to make the outline
%   both thick and nicely rounded
%
% Returns:
% raw - an image of heatmap upscaled to (X*upscale)*(Y*upscale), with the
%   outlines and tags on it
function raw = rois_outlines(heatmap, rois, tags, varargin)
	p = inputParser;
	p.addParameter('upscale', 4);
	p.addParameter('thickness', 1);
	parse(p, varargin{:});
	upscale = p.Results.upscale;
	thickness = p.Results.thickness;

	if isempty(rois)
		raw = [];
		return;
	end

	if ~isempty(tags) && length(rois) ~= length(tags)
		error(sprintf("Mismatch of ROI count %d and tag count %d", length(rois), length(tags)));
	end

	blur_kernel = fspecial('disk', upscale);
	outlines = zeros(size(rois(1).raw) * upscale);
	for i = 1:length(rois)
		scaled = imresize(rois(i).normalized2, upscale);
		if upscale >= 2
			% blur to produce a smooth outline
			scaled = (scaled ~= 0);
			scaled = conv2(scaled, blur_kernel, 'same');
			scaled = (scaled >= 0.75);
		end

		% bwperim finds the edge pixels within the painted region,
		% so to paint them around ROI, invert the image
		oline = bwperim(scaled == 0);
		% but bwperim then also puts a perimeter on the outer boundary of the
		% image, so erase that part
		oline(1, :) = 0;
		oline(end, :) = 0;
		oline(:, 1) = 0;
		oline(:, end) = 0;

		for t = 2:thickness
			% grow the line thickness outwards
			scaled = scaled + oline;
			oline = oline + bwperim(scaled == 0);
			% erase the perimeter on the image boundary, same as above
			oline(1, :) = 0;
			oline(end, :) = 0;
			oline(:, 1) = 0;
			oline(:, end) = 0;
		end

		outlines = (outlines + oline) ~= 0;
	end

	raw = heatmap;

	bottom = min(reshape(raw, 1, []));
	sorted = sort(reshape(raw, 1, []));
	pct = floor(size(sorted, 2) / 30);
	toplim = sorted(length(sorted) - pct);
	too_high = raw > toplim;
	raw = (max(raw .* ~too_high + toplim * too_high, [], 3) - bottom) * 200 / (toplim - bottom);

	raw = max(imresize(raw, upscale), outlines * 255);

	font = reshape([ ...
		[ ...
		0, 1, 1, 0; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		0, 1, 1, 0; ...
		], [...
		0, 0, 1, 0; ...
		0, 1, 1, 0; ...
		01 0, 1, 0; ...
		0, 0, 1, 0; ...
		0, 0, 1, 0; ...
		0, 0, 1, 0; ...
		0, 0, 1, 0; ...
		0, 1, 1, 1; ...
		], [...
		0, 1, 1, 0; ...
		1, 0, 0, 1; ...
		0, 0, 0, 1; ...
		0, 0, 1, 0; ...
		0, 1, 0, 0; ...
		1, 0, 0, 0; ...
		1, 0, 0, 0; ...
		1, 1, 1, 1; ...
		], [...
		1, 1, 1, 1; ...
		0, 0, 0, 1; ...
		0, 0, 1, 0; ...
		0, 1, 1, 0; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
		1, 1, 1, 0; ...
		], [...
		0, 0, 1, 1; ...
		0, 0, 1, 1; ...
		0, 1, 0, 1; ...
		0, 1, 0, 1; ...
		1, 0, 0, 1; ...
		1, 1, 1, 1; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
		], [...
		1, 1, 1, 1; ...
		1, 0, 0, 0; ...
		1, 0, 0, 0; ...
		1, 1, 1, 0; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
	
		1, 1, 1, 0; ...
		], [...
		0, 1, 1, 1; ...
		1, 0, 0, 0; ...
		1, 0, 0, 0; ...
		1, 1, 1, 0; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		0, 1, 1, 0; ...
		], [...
		1, 1, 1, 1; ...
		0, 0, 0, 1; ...
		0, 0, 1, 0; ...
		0, 0, 1, 0; ...
		0, 1, 0, 0; ...
		0, 1, 0, 0; ...
		1, 0, 0, 0; ...
		1, 0, 0, 0; ...
		], [...
		0, 1, 1, 0; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		0, 1, 1, 0; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		0, 1, 1, 0; ...
		], [...
		0, 1, 1, 0; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		1, 0, 0, 1; ...
		0, 1, 1, 1; ...
		0, 0, 0, 1; ...
		0, 0, 0, 1; ...
		1, 1, 1, 0; ...
		] ], 8, 4, []);

	fontht = 8;
	fontwd = 4;
		
	if ~isempty(tags)
		% draw the labels
		labels = zeros(size(rois(1).raw) * upscale);
		for i = 1:length(rois)
			t = tags(i);
			% digits are offset by 1 to produce indexes in the font
			digit1 = mod(floor(t / 10), 10) + 1;
			digit2 = mod(t, 10) + 1;
			x = floor( upscale * (rois(i).bbox.col_min + rois(i).bbox.col_max) / 2);
			y = floor( upscale * (rois(i).bbox.row_min + rois(i).bbox.row_max) / 2);

			% center of the font goes onto center of the bbox height
			from_y = y - fontht/2;
			to_y = y + fontht/2 - 1;
			if from_y < 0
				to_y = to_y - from_y;
				from_y = 0;
			end
			if to_y > size(raw, 1)
				from_y = from_y - (to_y - size(raw, 1));
				to_y = size(raw, 1);
			end

			if t < 10
				% center one digit
				from_x = x - fontwd/2;
				to_x = x + fontwd/2 - 1;
				if from_x < 0
					to_x = to_x - from_x;
					from_x = 0;
				end
				if to_x > size(raw, 2)
					from_x = from_x - (to_x - size(raw, 2));
					to_x = size(raw, 2);
				end

				labels(from_y:to_y, from_x:to_x) = font(:,:,digit2);
			else
				% center two digits
				% this creates limits for the whole number, with 2 pixels between digits
				from_x = x - fontwd - 1;
				to_x = x + fontwd;
				if from_x < 0
					to_x = to_x - from_x;
					from_x = 0;
				end
				if to_x > size(raw, 2)
					from_x = from_x - (to_x - size(raw, 2));
					to_x = size(raw, 2);
				end
				from_x1 = from_x;
				to_x1 = from_x1 + fontwd - 1;
				from_x2 = to_x1 + 3;
				to_x2 = from_x2 + fontwd - 1;

				labels(from_y:to_y, from_x1:to_x1) = font(:,:,digit1);
				labels(from_y:to_y, from_x2:to_x2) = font(:,:,digit2);
			end
		end
		raw = max(raw, labels * 255);
	end
end
